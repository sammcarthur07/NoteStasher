function updateStats(doc, config) {
  try {
    const body = doc.getBody();

    let paras = body.getParagraphs();
    while (paras.length > 0 && paras[0].getText().trim() === '') {
      safeRemovePara(paras[0]);
      paras = body.getParagraphs();
    }

    if (paras.length === 0 && !config.statsTop && !config.statsBottom && !config.statsAnywhere) {
      return;
    }

    const props = PropertiesService.getScriptProperties();
    const docId = doc.getId();
    const lastContentKey = 'lastContent_' + docId;
    const lastChangeTimeKey = 'lastChangeTime_' + docId;
    const longestTimeKey = 'longestTime_' + docId;
    const lastLiveTimeKey = 'lastLiveTime_' + docId;

    const lastStoredContent = props.getProperty(lastContentKey) || '';
    let lastChangeTimeMs = readNumberProperty(props, lastChangeTimeKey);
    let longestTime = readNumberProperty(props, longestTimeKey) || 0;
    let lastLiveTimeMs = readNumberProperty(props, lastLiveTimeKey);

    const fullText = body.getText();
    const cleanText = fullText.replace(/[⏰⏳⌛️⏳️][\s\S]*?Status: .*?(?:\n|$)/g, '');
    const contentChanged = cleanText !== lastStoredContent;

    const nowMs = Date.now();

    if (contentChanged || lastChangeTimeMs === null) {
      lastChangeTimeMs = nowMs;
      lastLiveTimeMs = nowMs;
    } else if (lastLiveTimeMs === null) {
      lastLiveTimeMs = nowMs;
    }

    const elapsedTime = Math.max(nowMs - lastChangeTimeMs, 0);
    const newLongestTime = Math.max(longestTime, elapsedTime);

    const tz = config.timezone || 'UTC';
    const timestampStr = Utilities.formatDate(new Date(lastChangeTimeMs), tz, 'dd/MM/yyyy hh:mm:ss a');
    const status = elapsedTime < 2 * 60 * 1000 ? 'Live' : 'Away';

    const clockStatsText =
      '⏰\n' +
      'Last edit: ' + timestampStr + ' — ' + formatElapsedTime(elapsedTime) + ' ago\n' +
      'Longest time away: ' + formatElapsedTime(newLongestTime) + '\n' +
      'Status: ' + status;

    const sandTimerStatsText =
      '⏳\r\n' +
      'Last edit: ' + timestampStr + ' — ' + formatElapsedTime(elapsedTime) + ' ago\n' +
      'Longest time away: ' + formatElapsedTime(newLongestTime) + '\n' +
      'Status: ' + status;

    let topPara = (paras.length > 0 && isStatsPara(paras[0])) ? paras[0] : null;
    if (config.statsTop) {
      if (topPara) {
        topPara.setText(clockStatsText);
      } else {
        body.insertParagraph(0, clockStatsText);
      }
    } else if (topPara) {
      safeRemovePara(topPara);
    }

    const updatedParas = body.getParagraphs();
    const topIsNowStats = updatedParas.length > 0 && isStatsPara(updatedParas[0]);
    let bottomFound = false;
    for (let i = updatedParas.length - 1; i >= (topIsNowStats ? 1 : 0); i--) {
      if (isStatsPara(updatedParas[i])) {
        if (config.statsBottom) {
          updatedParas[i].setText(clockStatsText);
        } else {
          safeRemovePara(updatedParas[i]);
        }
        bottomFound = true;
        break;
      }
    }
    if (!bottomFound && config.statsBottom) {
      body.appendParagraph(clockStatsText);
    }

    const finalParas = body.getParagraphs();
    const ANYWHERE_MARKERS = ['⏳', '⏳️', '⌛️'];
    const PRIMARY_ANYWHERE_MARKER = '⏳';

    if (config.statsAnywhere === true) {
      for (let i = 0; i < finalParas.length; i++) {
        const para = finalParas[i];
        const paraText = para.getText();
        const containsMarker = ANYWHERE_MARKERS.some(marker => paraText.includes(marker));
        const isAlreadyStats = paraText.includes('Last edit:');
        if (containsMarker && !isAlreadyStats) {
          para.setText(sandTimerStatsText);
        }
      }
    } else {
      for (let i = 0; i < finalParas.length; i++) {
        const text = finalParas[i].getText();
        if (text.startsWith(PRIMARY_ANYWHERE_MARKER + '\n') ||
            text.startsWith(PRIMARY_ANYWHERE_MARKER + '\r') ||
            text.startsWith(PRIMARY_ANYWHERE_MARKER + ' ')) {
          finalParas[i].setText(PRIMARY_ANYWHERE_MARKER);
        }
      }
    }

    lastLiveTimeMs = lastLiveTimeMs !== null ? lastLiveTimeMs : nowMs;
    props.setProperty(lastChangeTimeKey, String(lastChangeTimeMs));
    props.setProperty(lastLiveTimeKey, String(lastLiveTimeMs));
    props.setProperty(longestTimeKey, String(newLongestTime));
    props.setProperty(lastContentKey, cleanText);

  } catch (e) {
    Logger.log('CRITICAL Error in updateStats: ' + e.toString() + ' Stack: ' + e.stack);
  }
}
